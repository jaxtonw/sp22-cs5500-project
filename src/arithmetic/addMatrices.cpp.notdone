#include "./addition.h"
/**
 * @brief Sum two matrices together. Return summed matrix on Rank 0.
 *
 * @param A Matrix A
 * @param B Matrix B
 * @param m The row count of the matrices
 * @param n The column count of the matrices
 * @param comm The current MPI_Comm
 * @return The pointer to the result
 */
double *matricesSumPreDetermined(double *A, double *B, int m, int n, MPI_Comm comm)
{
    int rank, commSize, sendBuf, flag = 0;

    MPI_Comm_rank(comm, &rank);
    MPI_Comm_size(comm, &commSize);

    double *C = NULL;

    if (rank == 0)
    {
        MPI_Request request;
        MPI_Status status;
        int returnCounter = 0;
        int curRow = 0;
        int rowIdx;

        C = new double[m * n];
        double* arrayBuf = new double[n];

        while (1)
        {   
            // I can foresee a possibility where two PEs try to communicate at the same
            // time and we get mixed signals. I think the best way around this is to
            // take the rank value as the tag for the second send.
            MPI_Recv(&rowIdx, 1, MPI_INT, MPI_ANY_SOURCE, 0, comm, &status);
            MPI_Recv(&arrayBuf, n, MPI_DOUBLE, MPI_ANY_SOURCE, status.MPI_SOURCE, comm, MPI_STATUS_IGNORE);

            returnCounter++;

            // Been a while since I've used this, not sure if there's a better way?
            memcpy(C + rowIdx * n, arrayBuf, n);

            // Kill process when calculated
            if (returnCounter >= m)
            {
                // cout << "returnCounter: " << returnCounter << endl;
                // cout << "sending poison pill" << endl;
                sendBuf = POISON_PILL;
                for (size_t i = 1; i < commSize; i++)
                {
                    MPI_Send(&sendBuf, 1, MPI_UINT64_T, i, 0, comm);
                }
                break;
            }
        }
    }
    else
    {
        int recBuf;
        // np 2, m = 1000
        // curIdx rank 1 = 0
        // nextIdx rank 1 = 1000

        // np 4, m = 1000
        // curIdx rank 2 = 333
        int startIdx = (rank - 1) * (m / (commSize - 1));
        int endIdx = rank * (m / (commSize - 1));

        if (rank == commSize - 1)
        {
            endIdx = m;
        }

        // #ifndef MAKE_TEST
        //         cout << "rank: " << rank << ", startIdx: " << startIdx << ", endIdx: " << endIdx << endl;
        // #endif

        for (size_t j = startIdx; j < endIdx; j++)
        {
            vecBuf.idx = j;
            vecBuf.value = 0;

            for (size_t i = 0; i < n; i++)
            {
                vecBuf.value += x[i] * A[j * n + i];
            }

            MPI_Send(&vecBuf, 1, vectorCalcType, 0, 0, comm);
        }

        while (1)
        {
            MPI_Recv(&recBuf, 1, MPI_UINT64_T, MPI_ANY_SOURCE, 0, comm, MPI_STATUS_IGNORE);

            if (recBuf == POISON_PILL)
            {
                break;
            }
        }
    }

    // cout << "rank: " << rank << " exiting" << endl;

    return y;
}
